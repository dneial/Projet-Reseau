coloration de graphe au sein d'un réseau de processus interconnectés

1) envoi d'un message indiquant sa couleur (initialement son indice) à chaque voisin.


2)


0 si tu as pas de voisins tu prends la plus petite couleur dispo

1 Sommet de plus haut degré commence (ELECTION)
 -> choisit sa couleur (le 1ere dispo dans le tableau)
 -> envoie à tous ses voisins
    -> voisins reçoivent couleur et la suppriment de leur tableau
 termine

2 prochain sommet recommence algo (ELECTION)
 -> choisit sa couleur (le 1ere dispo dans le tableau )
  -> envoie à tous ses voisins
     -> voisins reçoivent couleur et la suppriment de leur tableau

  > 2 (0) : [0 1 2 3 4 5 6]
    1 (1) : ['0' 1 2 3 4 5 6]
    3 (0) : [0 '1' 2 3 4 5 6]
    4 (1) : ['0' 1 2 3 4 5 6]
    6 (2) : ['0' '1' 2 3 4 5 6]
    5 (1) : ['0' 1 2 3 4 5 6]

    7 (0) : [0 1 2 3 4 5 6]


     6          7
     |          |
     1 ------- '2'
     |          | \
     |          |  \
     |          |   \
     |          |    \
     |          |     \
     3          4 ---- 5

      1 ------- '2'          5
      |          | \          \
      |          |  \          \
      |          |   \          \
      |          |    \          \
      |          |     \          \
      3 -------- 4  --- 6          7

décrit dans g5:

     1 -------- 2
     |          |\
     |          | \
     |          |  \
     |          |   \
     |          |    \
     3          4 --- 5



  > 2 (0) : [0 1 2 3 4 5 6]
    1 (1) : ['0' 1 2 3 4 5 6]
    3 (0) : [0 '1' 2 3 4 5 6]
    4 (1) : ['0' 1 2 3 4 5 6]
    5 (2) : ['0' '1' 2 3 4 5 6]
    6 (0) : [0 1 '2' 3 4 5 6]

erreur de l'algo :  4 et 5 ont a même couleur.

    idée de correction :
si deux sommets ont la même couleur, celui de plus petit degré (plus petit indice si degré égal)
'barre' sa couleur actuelle et prend la plus petite couleur disponible dans le tableau.
qu'il transmettra par la suite à ses voisins.
les noeuds ne doivent donc pas s'arreter à la première couleur qu'ils reçoivent afin d'être atttentifs à un changement

(Problèmes possibles :
          - si mon voisin m'avait envoyé une couleur mais qu'il en change finalement,
            est-que l'ancienne est de nouveau disponible ?





    6 : [0 1 2 3 4 5 6]
    7 : [0 1 2 3 4 5 6]


    idée d'optimisation :
        - cas particuliers
            - graphe complet : n sommets && n(n-1)/2 arêtes  ==> n couleurs, pas besoin de faire tourner l'algorithme
            (on détecte juste si il y a n(n-1)/2 arêtes)

            - graphe étoile : n sommets && n-1 arêtes ==> 2 couleurs, pas besoin de faire tourner l'algorithme

            - graphe cycle : n sommets && n arêtes ==> 2(3) couleurs, pas besoin de faire tourner l'algorithme
            ( attention tester si chaque noeud a bien 1 voisins entrant et 1 voisins sortant )

            - graphe path : n sommets && n-1 arêtes ==> 2 couleurs, pas besoin de faire tourner l'algorithme
            ( attention tester si chaque noeud a bien 1 voisins entrant et/ou 1 voisins sortant )

Valeurs de retour de l'analyse du graphe :

    0 si graphe complet, (n couleurs)
    1 si graphe étoile,  (2 couleurs)
    2 si graphe cycle,   (2 couleurs) (3 si cycle impair)
    3 si graphe chemin,  (2 couleurs) (3 si erreur d'analyse cf return 3)
    4 si graphe aléatoire



    pseudo code algo séquentiel


    (first)
    attribue couleur
    envoie couleur à voisins
    boucle sur nombre voisins
        définit prochain >
        attend fin prochain
    fin boucle
    fin


    (pas first)
    do
        recevoir couleur ( maj tableau [voisin, état(colorié, pas colorié)])
    while ( !signal départ)
    attribue couleur
    envoie couleur à voisins (qui sont pas encore coloriés)
    boucle sur nombre voisins (qui sont pas encore coloriés)
        définit prochain
        attend fin prochain
    fin boucle
    signal fin au parent
    fin


    [définit prochain]




    0 [socket , 1]
    1 [socket , 2]
    2 [socket , 3]

Struct Map{
    int socket;
    int indice;
}


g7 : 11 sommets http://graphonline.ru/fr/?graph=hgqNSUQWDQNqweHA


probleme rencontré : 2 sommets voisins ont la même couleur

exemple :

        1--4
       / \
      /   \
     2     |  (problème de réseau
      \   /  sur cette arrête (1,3) :
       \  \  3 n'a pas encore reçu
        \ /   la couleur de 1)
         3

   >1 (0) : [0 1 2 3 4 ]
    2 (1) : ['0' 1 2 3 4 ]
    3 (0) : [0 '1' 2 3 4 ] -> 3 n'a pas supprimé 0 de son tableau
    4 (1) : ['0' 1 2 3 4 ]

    idée ecoute en continu :
quand j'ai attribué ma couleur,
je continue à écouter et si je reçois ma couleur de la part d'un voisin,
un de nous change et recommence l'algo

    changements que ça implique :
    - on doit se souvenir de la couleur de chaque voisin pour pouvoir la rendre disponible
      en cas de changement venant de ce dernier
    - je dois pouvoir différencier certains messages ?
     ( si je reçois ma nouvelle couleur de la part d'un voisin qui n'a pas encore réalisé
     que j'ai changé ? et qui va devoir changer aussi du coup)

propositions :
 > dater les messages, celui qui à envoyé en premier garde la couleur
    -> les parents sont aventagés ? du moins je crois

 > faire cette résolution après l'envoi au serveur ?
    -> permet de résoudre sur une base de coloration stable?
    -> le serveur doit gérer les changements de couleur et recompter les couleurs à la fin
